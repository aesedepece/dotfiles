* Emacs diff tool
#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/ediff :mkdirp true
  if [ ! ${#} -ge 2 ]; then
      echo 1>&2 "Usage: ${0} LOCAL REMOTE [MERGED BASE]"
      echo 1>&2 "       (LOCAL, REMOTE, MERGED, BASE can be provided by \`git mergetool'.)"
      exit 1
  fi
  
  # tools
  _EMACSCLIENT=`which emacsclient`
  _BASENAME=`basename`
  _CP=`cp`
  _EGREP=`egrep`
  _MKTEMP=`mktemp`
  
  # args
  _LOCAL=${1}
  _REMOTE=${2}
  if [ ${3} ] ; then
      _MERGED=${3}
  else
      _MERGED=${_REMOTE}
  fi
  if [ ${4} -a -r ${4} ] ; then
      _BASE=${4}
      _EDIFF=ediff-merge-files-with-ancestor
      _EVAL="${_EDIFF} \"${_LOCAL}\" \"${_REMOTE}\" \"${_BASE}\" nil \"${_MERGED}\""
  elif [ ${_REMOTE} = ${_MERGED} ] ; then
      _EDIFF=ediff
      _EVAL="${_EDIFF} \"${_LOCAL}\" \"${_REMOTE}\""
  else
      _EDIFF=ediff-merge-files
      _EVAL="${_EDIFF} \"${_LOCAL}\" \"${_REMOTE}\" nil \"${_MERGED}\""
  fi
  
  # console vs. X
  if [ "${TERM}" = "linux" ]; then
      unset DISPLAY
      _EMACSCLIENTOPTS="-t"
  else
      _EMACSCLIENTOPTS="-c"
  fi
  
  # run emacsclient
  ${_EMACSCLIENT} ${_EMACSCLIENTOPTS} -a "" -e "(${_EVAL})" 2>&1
  
  # check modified file
  if [ ! $(egrep -c '^(<<<<<<<|=======|>>>>>>>|####### Ancestor)' ${_MERGED}) = 0 ]; then
      _MERGEDSAVE=$(${_MKTEMP} --tmpdir `${_BASENAME} ${_MERGED}`.XXXXXXXXXX)
      ${_CP} ${_MERGED} ${_MERGEDSAVE}
      echo 1>&2 "Oops! Conflict markers detected in $_MERGED."
      echo 1>&2 "Saved your changes to ${_MERGEDSAVE}"
      echo 1>&2 "Exiting with code 1."
      exit 1
  fi
  
  exit 0
#+END_SRC
* Emacs pipe tool
#+BEGIN_SRC sh :shebang #!/bin/sh :tangle ~/.local/bin/emp :mkdirp true
    # -*- coding: utf-8 -*-
    # -*- Shell -*-

    NAME=`basename $0`
    BUFFER="*stdin*"
    function show_usage {
        echo "usage: <command that produces output> | $NAME [buffer-name]"
        exit 1
    }

    function input_to_file {
        while IFS= read -r line
        do
            echo "$line" >> $1
        done
    }

    function pipe_to_emacs {
        buffer=${1:-$BUFFER}
        file=`mktemp`
        input_to_file $file
        emacsclient -n --eval "(switch-to-buffer \"$buffer\")" --eval "(insert-file-contents \"$file\" nil nil nil t)" >/dev/null
        rm -f file
    }

    if [ $# -gt 1 ]; then
        show_usage
    else
        pipe_to_emacs $1
    fi
#+END_SRC
* Enumerate
#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/enum :mkdirp true
  #
  # examples:
  # enumerate filename
  # ... | enumerate
  # enumerate <(...)
  #
  
  NAME=`basename $0`
  
  function show_usage {
      echo <<EOF
  usage: $NAME filename
  
  Examples:
  enum filename
  ... | enum
  enum <(...)
  EOF
      exit 1
  }
  
  counter=1
  function enumerate {
      while read line; do
          echo "$((counter++)): $line"
      done
  }
  
  if [ $# -eq 0 ]; then
      enumerate
  elif [ ! -e $1 ]; then
      echo "$NAME: file doesn't exist."
      show_usage
  else
      # redefine stdin to come from whatever file is named by the first
      # command-line argument
      exec 0<$1
  
      enumerate
  fi
#+END_SRC
* Capture screen
Capture screen with scrot. If an argument is provided the screenshot
will be named *<argument>.png*, else it's going to be *last-capture.png*:
#+BEGIN_SRC sh :shebang #!/bin/sh :tangle ~/.local/bin/capture :mkdirp true
  if [ $# -eq 1 ]; then
      filename=$1
  else
      filename='last-capture'
  fi
  
  scrot -s -e "mv \$f ~/screenshots/$filename.png"
#+END_SRC
* Tangle
Tangle all the org files in a directory:
#+BEGIN_SRC sh :shebang #!/bin/sh :tangle ~/.local/bin/tangle :mkdirp true
  if [ $# -eq 0 ]; then
      dir=`pwd`
  else
      dir=$1
  fi
  
  FILES=""
  # wrap each argument in the code required to call tangle on it
  for i in `ls | grep \.org`; do
      FILES="$FILES \"$i\""
  done
  
  read -r -d '' TANGLE <<EOF
  (progn
       (require 'org)
       (require 'ob)
       (require 'ob-tangle)
       (mapc (lambda (file)
               (find-file (expand-file-name file "$dir"))
               (org-babel-tangle)
               (kill-buffer))
             '($FILES)))
  EOF
  
  emacs -Q --batch --eval "$TANGLE"
#+END_SRC
* Work IRC                                                            :crypt:
-----BEGIN PGP MESSAGE-----
Version: GnuPG v2.0.22 (GNU/Linux)

hQEMAxWSuK3W+kssAQf/fnAtKs2i+hfoTZM2Zj2mqGF3W+L1GG+Pk1Cj6zdpwPnq
I8toDKbPbQ6IH70E6NUk6ZajOKu2eMh2NMXgQF7qM83jRsvWlRxztc2udRyxQUKU
Kb1XrE47MtGree6gToiUeX6hfn4QQ5ljsL7COZCC/b9f2oOGYnjWhX4KdrZZLL4C
efZVGNGBxkLQ90ZqMDvUKQMzYSS8i3rtTHJdofka4+nPHg+4whriKcb4d/P57hlr
gTuYAZ+nv7KniR19CM+MKzq1xg30df9C+9MHZwbQP9scz3IDhm6IAi4a/X3zzXJO
xY0EDv9s44mTGdpl1PI4Vc4l7XrkxefzVRq0bgW/2NLAYQFraYYSHGg3GnYqTjNd
xC6MJzt6X4tzHFId8ietAzCp4HqhQsxl0LJdnILqk661P0QnEdLdmkakeFT9Th2Z
CkZ0sXAK+0dWsUM35becZR/pn0TK1+poz7W0uVjxBNu0Qa74R+5IDmvHF4j8wfkj
FqHerc6GQArVVv8UlsJVIHN6EY6XT7NBVKfeSCip8vW4v/SACwXPTgVULk9q501h
aBeyqNP1BG1r3tpAP190uos0OlUZW0WXlND4RpMvsaHeP/38t8R+yJZdc5DaRt1q
y49pWUE4mJnzgIlru/ut/NcbEeiDhl4pt7bNO8c9ET/6AD31IVWxBzKBS4qff13D
Lh6Um1Mmz31Xt5ltW4O4vcnFGfcyJaHSLKOBrJ7m8j1uJrs=
=CkTN
-----END PGP MESSAGE-----
