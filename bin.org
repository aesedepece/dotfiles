#+STARTUP: showall
* Table of contents                                                     :toc:
 - [[#pipe-into-emacs][Pipe into Emacs]]
 - [[#enumerate][Enumerate]]
 - [[#capture-screen][Capture screen]]
 - [[#tangle][Tangle]]
 - [[#clipboard][Clipboard]]
 - [[#kill-process-on-port][Kill process on port]]

* Pipe into Emacs
Emacs must be running in daemon mode.

#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/emp :mkdirp true
    # -*- coding: utf-8 -*-
    # -*- Shell -*-

    NAME=`basename $0`
    BUFFER="*stdin*"
    function show_usage {
        echo "usage: <command that produces output> | $NAME [buffer-name]"
        exit 1
    }

    function input_to_file {
        while IFS= read -r line
        do
            echo "$line" >> $1
        done
    }

    function pipe_to_emacs {
        buffer=${1:-$BUFFER}
        file=`mktemp`
        input_to_file $file
        emacsclient -n --eval "(switch-to-buffer \"$buffer\")" --eval "(insert-file-contents \"$file\" nil nil nil t)" >/dev/null
        rm -f file
    }

    if [ $# -gt 1 ]; then
        show_usage
    else
        pipe_to_emacs $1
    fi
#+END_SRC

* Enumerate
Enumerate the lines of a file
#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/enum :mkdirp true
  #
  # examples:
  # enumerate filename
  # ... | enumerate
  # enumerate <(...)
  #
  
  NAME=`basename $0`
  
  function show_usage {
      echo <<EOF
  usage: $NAME filename
  
  Examples:
  enum filename
  ... | enum
  enum <(...)
  EOF
      exit 1
  }
  
  counter=1
  function enumerate {
      while read line; do
          echo "$((counter++)): $line"
      done
  }
  
  if [ $# -eq 0 ]; then
      enumerate
  elif [ ! -e $1 ]; then
      echo "$NAME: file doesn't exist."
      show_usage
  else
      # redefine stdin to come from whatever file is named by the first
      # command-line argument
      exec 0<$1
  
      enumerate
  fi
#+END_SRC

* Capture screen
Capture screen with scrot. If an argument is provided the screenshot
will be named *<argument>.png*, else it's going to be *last-capture.png*:

#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/capture :mkdirp true
  if [ $# -eq 1 ]; then
      filename=$1
  else
      filename='last-capture'
  fi
  
  scrot -s -e "mv \$f ~/Screenshots/$filename.png"
#+END_SRC

* Tangle
Tangle all the org files in a directory:

#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/tangle :mkdirp true
  if [ $# -eq 0 ]; then
      dir=`pwd`
  else
      dir=$1
  fi
  
  FILES=""
  # wrap each argument in the code required to call tangle on it
  for i in `ls | grep \.org`; do
      FILES="$FILES \"$i\""
  done
  
  read -r -d '' TANGLE <<EOF
  (progn
       (require 'org)
       (require 'ob)
       (require 'ob-tangle)
       (mapc (lambda (file)
               (find-file (expand-file-name file "$dir"))
               (org-babel-tangle)
               (kill-buffer))
             '($FILES)))
  EOF
  
  emacs -Q --batch --eval "$TANGLE"
#+END_SRC

* Clipboard
#+BEGIN_SRC sh :tangle ~/.local/bin/cb :shebang #!/bin/bash
  if [ -t 0 ]; then
      xclip -o -selection clipboard
  else
      cat | xclip -i -selection clipboard
   fi
#+END_SRC

* Kill process on port
#+BEGIN_SRC sh :tangle ~/.local/bin/kill-on-port :shebang #!/bin/bash
  lsof -i tcp:$1 | grep LISTEN | cut -d' ' -f3 | xargs kill
#+END_SRC
