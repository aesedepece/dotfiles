* Emacs diff tool
#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/ediff :mkdirp true
  if [ ! ${#} -ge 2 ]; then
      echo 1>&2 "Usage: ${0} LOCAL REMOTE [MERGED BASE]"
      echo 1>&2 "       (LOCAL, REMOTE, MERGED, BASE can be provided by \`git mergetool'.)"
      exit 1
  fi
  
  # tools
  _EMACSCLIENT=`which emacsclient`
  _BASENAME=`basename`
  _CP=`cp`
  _EGREP=`egrep`
  _MKTEMP=`mktemp`
  
  # args
  _LOCAL=${1}
  _REMOTE=${2}
  if [ ${3} ] ; then
      _MERGED=${3}
  else
      _MERGED=${_REMOTE}
  fi
  if [ ${4} -a -r ${4} ] ; then
      _BASE=${4}
      _EDIFF=ediff-merge-files-with-ancestor
      _EVAL="${_EDIFF} \"${_LOCAL}\" \"${_REMOTE}\" \"${_BASE}\" nil \"${_MERGED}\""
  elif [ ${_REMOTE} = ${_MERGED} ] ; then
      _EDIFF=ediff
      _EVAL="${_EDIFF} \"${_LOCAL}\" \"${_REMOTE}\""
  else
      _EDIFF=ediff-merge-files
      _EVAL="${_EDIFF} \"${_LOCAL}\" \"${_REMOTE}\" nil \"${_MERGED}\""
  fi
  
  # console vs. X
  if [ "${TERM}" = "linux" ]; then
      unset DISPLAY
      _EMACSCLIENTOPTS="-t"
  else
      _EMACSCLIENTOPTS="-c"
  fi
  
  # run emacsclient
  ${_EMACSCLIENT} ${_EMACSCLIENTOPTS} -a "" -e "(${_EVAL})" 2>&1
  
  # check modified file
  if [ ! $(egrep -c '^(<<<<<<<|=======|>>>>>>>|####### Ancestor)' ${_MERGED}) = 0 ]; then
      _MERGEDSAVE=$(${_MKTEMP} --tmpdir `${_BASENAME} ${_MERGED}`.XXXXXXXXXX)
      ${_CP} ${_MERGED} ${_MERGEDSAVE}
      echo 1>&2 "Oops! Conflict markers detected in $_MERGED."
      echo 1>&2 "Saved your changes to ${_MERGEDSAVE}"
      echo 1>&2 "Exiting with code 1."
      exit 1
  fi
  
  exit 0
#+END_SRC
* Emacs pipe tool
#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/emp :mkdirp true
    # -*- coding: utf-8 -*-
    # -*- Shell -*-

    NAME=`basename $0`
    BUFFER="*stdin*"
    function show_usage {
        echo "usage: <command that produces output> | $NAME [buffer-name]"
        exit 1
    }

    function input_to_file {
        while IFS= read -r line
        do
            echo "$line" >> $1
        done
    }

    function pipe_to_emacs {
        buffer=${1:-$BUFFER}
        file=`mktemp`
        input_to_file $file
        emacsclient -n --eval "(switch-to-buffer \"$buffer\")" --eval "(insert-file-contents \"$file\" nil nil nil t)" >/dev/null
        rm -f file
    }

    if [ $# -gt 1 ]; then
        show_usage
    else
        pipe_to_emacs $1
    fi
#+END_SRC
* Enumerate
#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/enum :mkdirp true
  #
  # examples:
  # enumerate filename
  # ... | enumerate
  # enumerate <(...)
  #
  
  NAME=`basename $0`
  
  function show_usage {
      echo <<EOF
  usage: $NAME filename
  
  Examples:
  enum filename
  ... | enum
  enum <(...)
  EOF
      exit 1
  }
  
  counter=1
  function enumerate {
      while read line; do
          echo "$((counter++)): $line"
      done
  }
  
  if [ $# -eq 0 ]; then
      enumerate
  elif [ ! -e $1 ]; then
      echo "$NAME: file doesn't exist."
      show_usage
  else
      # redefine stdin to come from whatever file is named by the first
      # command-line argument
      exec 0<$1
  
      enumerate
  fi
#+END_SRC
* Capture screen
Capture screen with scrot. If an argument is provided the screenshot
will be named *<argument>.png*, else it's going to be *last-capture.png*:
#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/capture :mkdirp true
  if [ $# -eq 1 ]; then
      filename=$1
  else
      filename='last-capture'
  fi
  
  scrot -s -e "mv \$f ~/screenshots/$filename.png"
#+END_SRC
* Tangle
Tangle all the org files in a directory:
#+BEGIN_SRC sh :shebang #!/bin/bash :tangle ~/.local/bin/tangle :mkdirp true
  if [ $# -eq 0 ]; then
      dir=`pwd`
  else
      dir=$1
  fi
  
  FILES=""
  # wrap each argument in the code required to call tangle on it
  for i in `ls | grep \.org`; do
      FILES="$FILES \"$i\""
  done
  
  read -r -d '' TANGLE <<EOF
  (progn
       (require 'org)
       (require 'ob)
       (require 'ob-tangle)
       (mapc (lambda (file)
               (find-file (expand-file-name file "$dir"))
               (org-babel-tangle)
               (kill-buffer))
             '($FILES)))
  EOF
  
  emacs -Q --batch --eval "$TANGLE"
#+END_SRC
* Clipboard
#+BEGIN_SRC sh :tangle ~/.local/bin/cb :shebang #!/bin/bash
  if [ -t 0 ]; then
      xclip -o -selection clipboard
  else
      cat | xclip -i -selection clipboard
   fi
#+END_SRC
* Kill process on port
#+BEGIN_SRC sh :tangle ~/.local/bin/kill-on-port :shebang #!/bin/bash
  lsof -i tcp:$1 | grep LISTEN | cut -d' ' -f3 | xargs kill
#+END_SRC
