* Window Manager
** i3 (currently used)
*** i3
:PROPERTIES:
:tangle: ~/.i3/config
:mkdirp: true
:END:

#+BEGIN_SRC conf
  # This file has been auto-generated by i3-config-wizard(1).
  # It will not be overwritten, so edit it as you like.
  #
  # Should you change your keyboard layout somewhen, delete
  # this file and re-run i3-config-wizard(1).
  #
  
  # i3 config file (v4)
  #
  # Please see http://i3wm.org/docs/userguide.html for a complete reference!
  
  set $mod Mod4
  
  # Font for window titles. Will also be used by the bar unless a different font
  # is used in the bar {} block below. ISO 10646 = Unicode
  # font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1
  # The font above is very space-efficient, that is, it looks good, sharp and
  # clear in small sizes. However, if you need a lot of unicode glyphs or
  # right-to-left text rendering, you should instead use pango for rendering and
  # chose a FreeType font, such as:
  font pango:DejaVu Sans Mono 10
  
  # Use Mouse+$mod to drag floating windows to their wanted position
  floating_modifier $mod
  
  # start a terminal
  bindsym $mod+Return exec i3-sensible-terminal
  
  # kill focused window
  bindsym $mod+q kill
  
  # start dmenu (a program launcher)
  bindsym $mod+p exec --no-startup-id dmenu_run
  # There also is the (new) i3-dmenu-desktop which only displays applications
  # shipping a .desktop file. It is a wrapper around dmenu, so you need that
  # installed.
  # bindsym $mod+d exec --no-startup-id i3-dmenu-desktop
  
  # change focus
  bindsym $mod+j focus left
  bindsym $mod+k focus down
  bindsym $mod+l focus up
  bindsym $mod+semicolon focus right
  
  # alternatively, you can use the cursor keys:
  # bindsym $mod+Left focus left
  # bindsym $mod+Down focus down
  # bindsym $mod+Up focus up
  # bindsym $mod+Right focus right
  
  # move focused window
  bindsym $mod+Shift+j move left
  bindsym $mod+Shift+k move down
  bindsym $mod+Shift+l move up
  bindsym $mod+Shift+semicolon move right
  
  # alternatively, you can use the cursor keys:
  bindsym $mod+Shift+Left move left
  bindsym $mod+Shift+Down move down
  bindsym $mod+Shift+Up move up
  bindsym $mod+Shift+Right move right
  
  # split in horizontal orientation
  bindsym $mod+h split h
  
  # split in vertical orientation
  bindsym $mod+v split v
  
  # enter fullscreen mode for the focused container
  bindsym $mod+f fullscreen
  
  # change container layout (stacked, tabbed, toggle split)
  bindsym $mod+s layout stacking
  bindsym $mod+w layout tabbed
  bindsym $mod+e layout toggle split
  
  # toggle tiling / floating
  bindsym $mod+Shift+space floating toggle
  
  # change focus between tiling / floating windows
  bindsym $mod+space focus mode_toggle
  
  # focus the parent container
  bindsym $mod+a focus parent
  
  # focus the child container
  bindsym $mod+d focus child
  
  # switch to workspace
  bindsym $mod+1 workspace 1
  bindsym $mod+2 workspace 2
  bindsym $mod+3 workspace 3
  bindsym $mod+4 workspace 4
  bindsym $mod+5 workspace 5
  bindsym $mod+6 workspace 6
  bindsym $mod+7 workspace 7
  bindsym $mod+8 workspace 8
  bindsym $mod+9 workspace 9
  bindsym $mod+0 workspace 10
  
  # move focused container to workspace
  bindsym $mod+Shift+1 move container to workspace 1
  bindsym $mod+Shift+2 move container to workspace 2
  bindsym $mod+Shift+3 move container to workspace 3
  bindsym $mod+Shift+4 move container to workspace 4
  bindsym $mod+Shift+5 move container to workspace 5
  bindsym $mod+Shift+6 move container to workspace 6
  bindsym $mod+Shift+7 move container to workspace 7
  bindsym $mod+Shift+8 move container to workspace 8
  bindsym $mod+Shift+9 move container to workspace 9
  bindsym $mod+Shift+0 move container to workspace 10
  
  # reload the configuration file
  bindsym $mod+Shift+c reload
  # restart i3 inplace (preserves your layout/session, can be used to upgrade i3)
  bindsym $mod+Shift+r restart
  # exit i3 (logs you out of your X session)
  bindsym $mod+Shift+e exec "i3-nagbar -t warning -m 'You pressed the exit shortcut. Do you really want to exit i3? This will end your X session.' -b 'Yes, exit i3' 'i3-msg exit'"
  
  # resize window (you can also use the mouse for that)
  mode "resize" {
          # These bindings trigger as soon as you enter the resize mode
  
          # Pressing left will shrink the window’s width.
          # Pressing right will grow the window’s width.
          # Pressing up will shrink the window’s height.
          # Pressing down will grow the window’s height.
          bindsym j resize shrink width 10 px or 10 ppt
          bindsym k resize grow height 10 px or 10 ppt
          bindsym l resize shrink height 10 px or 10 ppt
          bindsym semicolon resize grow width 10 px or 10 ppt
  
          # same bindings, but for the arrow keys
          bindsym Left resize shrink width 10 px or 10 ppt
          bindsym Down resize grow height 10 px or 10 ppt
          bindsym Up resize shrink height 10 px or 10 ppt
          bindsym Right resize grow width 10 px or 10 ppt
  
          # back to normal: Enter or Escape
          bindsym Return mode "default"
          bindsym Escape mode "default"
  }
  
  bindsym $mod+r mode "resize"
  
  # Start i3bar to display a workspace bar (plus the system information i3status
  # finds out, if available)
  bar {
          status_command i3status
  
          colors {
                  background #002b36
                  statusline #ffa72c

                  focused_workspace  #6c71c4 #545abf #ffffff
                  active_workspace   #002b36 #002b36 #ffffff
                  inactive_workspace #002b36 #002b36 #888888
                  urgent_workspace   #2f343a #900000 #ffffff
          }
  }
  
  # Move the current workspace to the next output
  # (effectively toggles when you only have two outputs)
  bindsym $mod+x move workspace to output right
  bindsym $mod+Shift+x move workspace to output left
  # bindsym $mod+x exec ~/.i3/swap-outputs.py
  
  bindsym $mod+period [class="Emacs"] focus
  bindsym $mod+comma [class="Chromium"] focus

  # Make the currently focused window a scratchpad
  bindsym $mod+Shift+minus move scratchpad
  
  # Show the first scratchpad window
  bindsym $mod+minus scratchpad show
  
  # Show the sup-mail scratchpad window, if any.
  # bindsym mod4+s [title="^Sup ::"] scratchpad show
  
  bindsym $mod+Shift+plus exec amixer set Master playback 2%+
  bindsym $mod+equal exec amixer set Master playback 2%-
  
  hide_edge_borders both
#+END_SRC

Floating layout for certain applications:
#+BEGIN_SRC conf
  for_window [title="^Hangouts"] floating enable
  for_window [title="^Fast Tab Switcher"] floating enable
#+END_SRC

Easily switch back and forth between workspaces. Assume you are in
workspace 1 and switch to 2, using ~mod+2~ again will switch you back
to where you came from, that is 1, if you again press ~mod+2~ you will
switch forth to workspace 2:
#+BEGIN_SRC conf
  workspace_auto_back_and_forth yes
#+END_SRC

Launch unclutter which is program that hides your X mouse cursor
whenever you're not using it to prevent it from getting in the way.
Moving the mouse restores the mouse cursor:
#+BEGIN_SRC conf
  exec --no-startup-id unclutter
#+END_SRC

Launch dropbox daemon:
#+BEGIN_SRC conf
  exec --no-startup-id dropboxd start
#+END_SRC

Launch a shell script I have that randomly sets a wallpaper:
#+BEGIN_SRC conf
  exec --no-startup-id random-wallpaper
#+END_SRC
Additionally set the key-binding ~mod+g~ to randomly select a
wallpaper whenever we want:
#+BEGIN_SRC conf
  bindsym $mod+g exec --no-startup-id random-wallpaper
#+END_SRC

Launch [[https://github.com/chjj/compton][compton]] which is a compositor for X. I'm using the
configuration file [[compton][defined below]]:
#+BEGIN_SRC conf
  exec --no-startup-id compton -b --config ~/.compton.conf
#+END_SRC
*** i3 status bar
:PROPERTIES:
:tangle: ~/.i3status.conf
:END:

#+BEGIN_SRC conf
  # i3status configuration file.
  # see "man i3status" for documentation.
  
  # It is important that this file is edited as UTF-8.
  # The following line should contain a sharp s:
  # ß
  # If the above line is not correctly displayed, fix your editor first!
  
  general {
          colors = true
          interval = 1
  }
  
  order += "volume master"
  order += "disk /"
  order += "run_watch DHCP"
  order += "run_watch VPN"
  order += "ipv6"
  order += "wireless wlp1s0"
  order += "ethernet enp0s20u2"
  order += "battery 0"
  order += "load"
  order += "tztime local"
  
  wireless wlp1s0 {
          format_up = "W: (%quality at %essid, %bitrate) %ip"
          format_down = "W: down"
  }
  
  ethernet enp0s20u2 {
          # if you use %speed, i3status requires root privileges
          format_up = "E: %ip (%speed)"
          format_down = "E: down"
  }
  
  battery 0 {
          format = "%status %percentage %remaining"
  }
  
  run_watch DHCP {
          pidfile = "/var/run/dhclient*.pid"
  }
  
  run_watch VPN {
          pidfile = "/var/run/vpnc/pid"
  }
  
  tztime local {
          format = "%Y-%m-%d %H:%M"
  }
  
  load {
          format = "☰ %1min"
  }
  
  disk "/" {
          format = "%avail"
  }
  
  volume master {
          format = "♪: %volume"
          device = "default"
          mixer = "Master"
          mixer_idx = 0
  }
#+END_SRC
** dunst
:PROPERTIES:
:tangle: ~/.config/dunst/dunstrc
:mkdirp: true
:END:
#+BEGIN_SRC conf
  [global]
      font = Monospace 8
  
      # allow a small subset of html markup:
      # <b>bold</b>
      # <i>italic</i>
      # <s>strikethrough<s/>
      # <u>underline</u>
      #
      # for a complete reference see http://developer.gnome.org/pango/stable/PangoMarkupFormat.html
      # If markup is not allowed, those tags will be stripped out of the message.
      allow_markup = yes
  
      # The format of the message. Possible variables are:
      #   %a  appname
      #   %s  summary
      #   %b  body
      #   %i  iconname (including its path)
      #   %I  iconname (without its path)
      #   %p  progress value if set ([  0%] to [100%]) or nothing
      # Markup is allowed
      format = "<b>%s</b>\n%b"
  
      # Sort messages by urgency
      sort = yes
  
      # Show how many messages are currently hidden (because of geometry)
      indicate_hidden = yes
  
      # alignment of message text.
      # Possible values are "left", "center" and "right"
      alignment = left
  
      # The frequency with wich text that is longer than the notification
      # window allows bounces back and forth.
      # This option conflicts with 'word_wrap'.
      # Set to 0 to disable
      bounce_freq = 0
  
      # show age of message if message is older than show_age_threshold seconds.
      # set to -1 to disable
      show_age_threshold = 60
  
      # split notifications into multiple lines if they don't fit into geometry
      word_wrap = yes
  
      # ignore newlines '\n' in notifications
      ignore_newline = no
  
  
      # the geometry of the window
      # geometry [{width}]x{height}][+/-{x}+/-{y}]
      # The geometry of the message window.
      # The height is measured in number of notifications everything else in pixels. If the width
      # is omitted but the height is given ("-geometry x2"), the message window
      # expands over the whole screen (dmenu-like). If width is 0,
      # the window expands to the longest message displayed.
      # A positive x is measured from the left, a negative from the
      # right side of the screen.  Y is measured from the top and down respectevly.
      # The width can be negative. In this case the actual width is the
      # screen width minus the width defined in within the geometry option.
      geometry = "300x5-30+20"
  
      # The transparency of the window. range: [0; 100]
      # This option will only work if a compositing windowmanager is present (e.g. xcompmgr, compiz, etc..)
      transparency = 0
  
      # Don't remove messages, if the user is idle (no mouse or keyboard input)
      # for longer than idle_threshold seconds.
      # Set to 0 to disable.
      idle_threshold = 120
  
      # Which monitor should the notifications be displayed on.
      monitor = 0
  
      # Display notification on focused monitor. Possible modes are:
      # mouse: follow mouse pointer
      # keyboard: follow window with keyboard focus
      # none: don't follow anything
      #
      # "keyboard" needs a windowmanager that exports the _NET_ACTIVE_WINDOW property.
      # This should be the case for almost all modern windowmanagers.
      #
      # If this option is set to mouse or keyboard, the monitor option will be
      # ignored.
      follow = mouse
  
      # should a notification popped up from history be sticky or
      # timeout as if it would normally do.
      sticky_history = yes
  
      # The height of a single line. If the height is smaller than the font height,
      # it will get raised to the font height.
      # This adds empty space above and under the text.
      line_height = 0
  
      # Draw a line of 'separatpr_height' pixel height between two notifications.
      # Set to 0 to disable
      separator_height = 2
  
      # padding between text and separator
      padding = 8
  
      # horizontal padding
      horizontal_padding = 8
  
      # Define a color for the separator.
      # possible values are:
      #  * auto: dunst tries to find a color fitting to the background
      #  * foreground: use the same color as the foreground
      #  * frame: use the same color as the frame.
      #  * anything else will be interpreted as a X color
      separator_color = frame
  
      # print a notification on startup
      # This is mainly for error detection, since dbus (re-)starts dunst
      # automatically after a crash.
      startup_notification = false
  
      # dmenu path
      dmenu = /usr/bin/dmenu -p dunst:
  
      # browser for opening urls in context menu
      browser = /usr/bin/firefox -new-tab
  
  [frame]
      width = 3
      color = "#aaaaaa"
  
  [shortcuts]
      # shortcuts are specified as [modifier+][modifier+]...key
      # available modifiers are 'ctrl', 'mod1' (the alt-key), 'mod2', 'mod3'
      # and 'mod4' (windows-key)
      # xev might be helpful to find names for keys
  
      # close notification
      # close = ctrl+space
      close = mod4+space
  
      # close all notifications
      # close_all = ctrl+shift+space
      close_all = mod4+n
  
      # redisplay last message(s)
      # On the US keyboard layout 'grave' is normally above TAB and left of '1'.
      # history = ctrl+grave
      history = mod4+grave
  
      # context menu
      context = ctrl+shift+period
  
  [urgency_low]
      # IMPORTANT: colors have to be defined in quotation marks.
      # Otherwise the '#' and following  would be interpreted as a comment.
      background = "#222222"
      foreground = "#888888"
      timeout = 10
  
  [urgency_normal]
      background = "#285577"
      foreground = "#ffffff"
      timeout = 10
  
  [urgency_critical]
      background = "#900000"
      foreground = "#ffffff"
      timeout = 0
  
  
  # Every section that isn't one of the above is interpreted as a rules
  # to override settings for certain messages.
  # Messages can be matched by 'appname', 'summary', 'body' or 'icon'
  # and you can override the 'timeout', 'urgency', 'foreground', 'background'
  # and 'format'.
  # Shell-like globbing will get expanded.
  #
  # SCRIPTING
  # you can specify a script that gets run when the rule matches by setting
  # the 'script' option.
  # The script will be called as follows:
  # script appname summary body icon urgency
  # where urgency can be "LOW", "NORMAL" or "CRITICAL".
  #
  # NOTE: if you don't want a notification to be displayed, set the format to ""
  # NOTE: It might be helpful to run dunst -print in a terminal in order to find
  # fitting options for rules.
  
  #[espeak]
  #    summary = "*"
  #    script = dunst_espeak.sh
  
  #[script-test]
  #    summary = "*script*"
  #    script = dunst_test.sh
  
  #[ignore]
  ## This notification will not be displayed
  #    summary = "foobar"
  #    format = ""
  
  #[signed_on]
  #    appname = Pidgin
  #    summary = "*signed on*"
  #    urgency = low
  #
  #[signed_off]
  #    appname = Pidgin
  #    summary = *signed off*
  #    urgency = low
  #
  #[says]
  #    appname = Pidgin
  #    summary = *says*
  #    urgency = critical
  #
  #[twitter]
  #    appname = Pidgin
  #    summary = *twitter.com*
  #    urgency = normal
  #
#+END_SRC
** xmonad
#+BEGIN_SRC haskell :tangle ~/.xmonad/xmonad.hs :mkdirp true
  import System.IO (hPutStrLn)
  import System.Exit
  
  import qualified Data.Map as M
  import Data.Ratio ((%))
  
  import XMonad
  import XMonad.Util.Scratchpad
  import XMonad.Hooks.DynamicLog
  import XMonad.Hooks.ManageDocks
  import XMonad.Hooks.ManageHelpers
  
  -- Layouts
  import XMonad.Layout.Spacing
  import XMonad.Layout.Fullscreen
  import XMonad.Layout.NoBorders
  import XMonad.Layout.PerWorkspace
  import XMonad.Layout.SimplestFloat
  import XMonad.Layout.Tabbed
  import XMonad.Layout.ResizableTile
  import XMonad.Layout.Circle
  import XMonad.Layout.Grid
  import XMonad.Layout.ThreeColumns
  import XMonad.Util.WorkspaceCompare
  
  -- window rules
  import XMonad.Actions.FloatKeys
  
  -- status bar
  import XMonad.Hooks.DynamicLog hiding (xmobar, xmobarPP,  xmobarColor)
  import qualified XMonad.Actions.FlexibleResize as FlexibleResize
  import XMonad.Util.Run(spawnPipe)
  import XMonad.Util.EZConfig(additionalKeys)
  import qualified XMonad.StackSet as W
  
  main = do
    xmproc <- spawnPipe "xmobar ~/.xmonad/xmobarrc.hs"
    xmonad $ defaultConfig {
        modMask = mod4Mask
        , workspaces = ikameWorkspaces
        , focusFollowsMouse = False
        , terminal = ikameTerminal
        , manageHook = ikameManageHook
        , keys = ikameKeys
        , mouseBindings = ikameMouseBindings
        , borderWidth = 1
        , normalBorderColor = "#004358"
        , focusedBorderColor = "#ffa72c"
        , layoutHook = smartBorders $ ikameLayout
        , logHook = dynamicLogWithPP $ xmobarPP {
                                                ppOutput = hPutStrLn xmproc
                                                , ppSort = fmap (.scratchpadFilterOutWorkspace) getSortByTag
                                                , ppCurrent = wrap "<fc=#ffa72c>" "</fc>" . (\wsId -> wsId)
                                                , ppWsSep = " "
                                                , ppTitle = (\str -> "")
                                                , ppLayout = (\str -> "")
                                                , ppVisible = wrap "<fc=#ffa72c>(" ")</fc>" . (\wsId -> wsId)
                                                , ppHidden = wrap "<fc=#004358>" ".</fc>" . (\wsId -> wsId)
                                                , ppHiddenNoWindows = xmobarColor "#004358" ""}
        }
  
  ikameWorkspaces = ["1", "2", "3" , "4", "5"]
  ikameWorkspacesKeys = [xK_1, xK_2, xK_3, xK_4, xK_5]
  ikameTerminal = "urxvt"
  ikameScratchPad = ikameTerminal
  ikameLauncher = "~/.launcher"
  
  tabConfig = defaultTheme {
    activeColor         = "#fdf6e3"
    , inactiveColor       = "#fdf6e3"
    , activeBorderColor   = "#fdf6e3"
    , inactiveBorderColor = "#fdf6e3"
    , activeTextColor     = "#ffa72c"
    , inactiveTextColor   = "#004358"
    , fontName            = "xft:Terminus:pixelsize=12:antialias=true:embolden=true"
    , decoHeight          = 14
  }
  
  ikameManageHook = composeAll
      [ className =? "MPlayer"        --> doFloat
      , className =? "Gimp"           --> doFloat
      , resource =? "feh"             --> doFloat
      , resource =? "skype"           --> doFloat
      , resource =? "steam"           --> doFloat
      , resource =? "spotify"         --> doFloat
      , resource =? "emacs"           --> doShift (ikameWorkspaces !! 0)
      , resource =? "chromium"        --> doShift (ikameWorkspaces !! 1)
      , resource =? "zathura"         --> doShift (ikameWorkspaces !! 2)
      ] <+> manageScratchPad
  
  manageScratchPad :: ManageHook
  manageScratchPad = scratchpadManageHook (W.RationalRect l t w h)
    where
      h = 0.6     -- terminal height
      w = 1       -- terminal width
      t = 0.2     -- distance from top edge
      l = 0       -- distance from left edge
  
  ikameKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList $
      -- launch a terminal
      [ ((modm,               xK_Return), spawn $ XMonad.terminal conf)
  
      , ((modm,               xK_p     ), spawn ikameLauncher)
  
      -- volume control
      , ((modm,               xK_i ), spawn "amixer set Master playback 2%+")
      , ((modm,               xK_d), spawn "amixer set Master playback 2%-")
  
      -- lock screen
      , ((modm,               xK_0), spawn "slock")
  
      -- change background
      , ((modm,               xK_g), spawn "~/bin/wallpaper.sh")
  
      -- scratchpad
      , ((modm,               xK_s     ), scratchPad)
  
      -- screenshots
      , ((0,                  xK_Print),  screenshot)
  
      -- close focused window
      , ((modm .|. shiftMask, xK_c     ), kill)
  
       -- Rotate through the available layout algorithms
      , ((modm,               xK_space ), sendMessage NextLayout)
  
      --  Reset the layouts on the current workspace to default
      , ((modm .|. shiftMask, xK_space ), setLayout $ XMonad.layoutHook conf)
  
      -- Resize viewed windows to the correct size
      , ((modm,               xK_n     ), refresh)
  
      -- Move focus to the next window
      , ((modm,               xK_Tab   ), windows W.focusDown)
  
      -- Move focus to the next window
      , ((modm,               xK_j     ), windows W.focusDown)
  
      -- Move focus to the previous window
      , ((modm,               xK_k     ), windows W.focusUp  )
  
      -- Move focus to the master window
      , ((modm,               xK_m     ), windows W.focusMaster  )
  
      -- Swap the focused window and the master window
      , ((modm .|. shiftMask, xK_m), windows W.swapMaster)
  
      -- Swap the focused window with the next window
      , ((modm .|. shiftMask, xK_j     ), windows W.swapDown  )
  
      -- Swap the focused window with the previous window
      , ((modm .|. shiftMask, xK_k     ), windows W.swapUp    )
  
      -- Shrink the master area
      , ((modm,               xK_h     ), sendMessage Shrink)
  
      -- Expand the master area
      , ((modm,               xK_l     ), sendMessage Expand)
  
      -- Push window back into tiling
      , ((modm,               xK_t     ), withFocused $ windows . W.sink)
  
      -- Increment the number of windows in the master area
      , ((modm              , xK_comma ), sendMessage (IncMasterN 1))
  
      -- Deincrement the number of windows in the master area
      , ((modm              , xK_period), sendMessage (IncMasterN (-1)))
  
      -- , ((modm,               xK_h     ), withFocused (keysResizeWindow (10, 0) (0, 0)))
      -- , ((modm,               xK_v     ), withFocused (keysResizeWindow (0, 10) (0, 0)))
      -- , ((modm,               xK_a     ), withFocused (keysAbsResizeWindow (10, 10) (0, 0)))
      -- , ((modm .|. shiftMask, xK_h     ), withFocused (keysResizeWindow (-10, 0) (0, 0)))
      -- , ((modm .|. shiftMask, xK_v     ), withFocused (keysResizeWindow (0, -10) (0, 0)))
      -- , ((modm .|. shiftMask, xK_a     ), withFocused (keysAbsResizeWindow (-10, -10) (0, 0)))
  
      -- center floating window
      , ((modm,               xK_c     ), withFocused (keysMoveWindowTo (0, 0) (-1%2, -1%2)))
  
      -- Quit xmonad
      , ((modm .|. shiftMask, xK_q     ), io (exitWith ExitSuccess))
  
      -- Reload xmonad
      , ((modm,               xK_q     ), spawn "xmonad --recompile; xmonad --restart")
      ]
  
      ++
  
      --
      -- mod-[1..9], Switch to workspace N
      -- mod-shift-[1..9], Move client to workspace N
      --
      [((m .|. modm, k), windows $ f i)
          | (i, k) <- zip (XMonad.workspaces conf) ikameWorkspacesKeys
          , (f, m) <- [(W.greedyView, 0), (W.shift, shiftMask)]]
  
      ++
  
      -- mod-{w,e,r} %! Switch to physical/Xinerama screens 1, 2, or 3
      -- mod-shift-{w,e,r} %! Move client to screen 1, 2, or 3
      [((m .|. modm, key), screenWorkspace sc >>= flip whenJust (windows . f))
          | (key, sc) <- zip [xK_w, xK_e, xK_r] [0..]
          , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]
  
    where
      scratchPad = scratchpadSpawnActionTerminal ikameScratchPad
      screenshot = spawn "scrot -s 'mv $f ~/screenshots'"
  
  ikameMouseBindings (XConfig {XMonad.modMask = modm}) = M.fromList $
    [
      -- mod-<button 1> Set the window to floating mode and move by dragging
      ((modm, button1), (\w -> focus w >> mouseMoveWindow w))
      -- mod-button2, Raise the window to the top of the stack
      , ((modm, button2), (\w -> focus w >> windows W.swapMaster))
      -- mod-<button 3> Set the window to floating mode and resize by dragging
      , ((modm, button3), (\w -> focus w >> mouseResizeWindow w))
    ]
  
  
  ikameLayout = onWorkspace (ikameWorkspaces !! 0) (avoidStruts (tiledSpace ||| tiled ||| fullTile) ||| fullScreen)
                $ onWorkspace (ikameWorkspaces !! 1) (avoidStruts (tiledSpace ||| tiled ||| borderlessTile ||| tabbedSpace) ||| fullScreen)
                $ onWorkspace (ikameWorkspaces !! 2) (avoidStruts gridded)
                $ avoidStruts (tiled ||| gridded ||| tiledSpace ||| tiled ||| bigMonitor ||| borderlessTile ||| simplestFloat)
    where
      fullTile       = ResizableTall nmaster delta ratio []
      fullScreen     = noBorders(fullscreenFull Full)
      tabbedSpace    = tabbed shrinkText tabConfig
      tiled          = spacing 15 $ ResizableTall nmaster delta ratio []
      tiledSpace     = spacing 40 $ ResizableTall nmaster delta ratio []
      bigMonitor     = spacing 5 $ ThreeColMid nmaster delta ratio
      borderlessTile = noBorders(fullTile)
      gridded        = spacing 20 $ Grid
      -- Default number of windows in master pane
      nmaster = 1
      -- Percent of the screen to increment when resizing
      delta = 5/100
      -- Default proportion of the screen taken up by main pane
      ratio = toRational (2/(1 + sqrt 5 :: Double))
  
#+END_SRC
#+BEGIN_SRC haskell :tangle ~/.xmonad/xmobarrc.hs :mkdirp true
  Config { font = "xft:Wendy:pixelsize=30:antialias=true:embolden=true"
         , bgColor = "#fdf6e3"
         , fgColor = "#004358"
         , position = BottomW C 100
         , lowerOnStart = True
         , commands = [ Run StdinReader
                      , Run Date "%I:%M %a %_d" "date" 10
                      ]
         , sepChar = "%"
         , alignSep = "}{"
         , template = "} %StdinReader% { %date%"
         }
#+END_SRC
** compton
:PROPERTIES:
:tangle: ~/.compton.conf
:END:

#+BEGIN_SRC conf
  # Shadow
  shadow = false;              # Enabled client-side shadows on windows.
  no-dock-shadow = true;      # Avoid drawing shadows on dock/panel windows.
  no-dnd-shadow = true;       # Don't draw shadows on DND windows.
  clear-shadow = true;        # Zero the part of the shadow's mask behind the window (experimental).
  shadow-radius = 7;      # The blur radius for shadows. (default 12)
  shadow-offset-x = -7;       # The left offset for shadows. (default -15)
  shadow-offset-y = -7;       # The top offset for shadows. (default -15)
  # shadow-opacity = 0.7;     # The translucency for shadows. (default .75)
  # shadow-red = 0.0;     # Red color value of shadow. (0.0 - 1.0, defaults to 0)
  # shadow-green = 0.0;       # Green color value of shadow. (0.0 - 1.0, defaults to 0)
  # shadow-blue = 0.0;        # Blue color value of shadow. (0.0 - 1.0, defaults to 0)
  shadow-exclude = [ "n:e:Notification", "class_g = 'conky'" ];    # Exclude conditions for shadows.
  shadow-ignore-shaped = true;
  
  # Opacity
  menu-opacity = 0.9;         # The opacity for menus. (default 1.0)
  # inactive-opacity = 0.9;         # Opacity of inactive windows. (0.1 - 1.0)
  #frame-opacity = 0.8;           # Opacity of window titlebars and borders. (0.1 - 1.0)
  inactive-opacity-override = true;   # Inactive opacity set by 'inactive-opacity' overrides value of _NET_WM_OPACITY.
  
  # Fading
  # fading = true;          # Fade windows during opacity changes.
  # fade-delta = 5;         # The time between steps in a fade in milliseconds. (default 10).
  # fade-in-step = 0.02;        # Opacity change between steps while fading in. (default 0.028).
  # fade-out-step = 0.02;       # Opacity change between steps while fading out. (default 0.03).
  # no-fading-openclose = true;   # Fade windows in/out when opening/closing.
  
  # Other
  #inactive-dim = 0.5;        # Dim inactive windows. (0.0 - 1.0, defaults to 0).
  mark-wmwin-focused = true;  # Try to detect WM windows and mark them as active.
  mark-ovredir-focused = true;
  detect-rounded-corners = true;
  
  # Window type settings
  wintypes:
  {
    tooltip = { fade = true; shadow = false; opacity = 0.75; };
  };
#+END_SRC
